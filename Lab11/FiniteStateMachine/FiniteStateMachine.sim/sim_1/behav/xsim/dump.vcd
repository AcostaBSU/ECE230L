$date
   Tue Apr  8 10:14:12 2025
$end

$version
  2024.2.0
$end

$timescale
  1ps
$end

$scope module test $end
$var reg 1 ! w $end
$var reg 1 " clk $end
$var reg 1 # reset $end
$var wire 1 $ z_onehot $end
$var wire 1 % z_binary $end
$var wire 5 & onehot_actual [4:0] $end
$var wire 3 ' binary_actual [2:0] $end
$scope module uut $end
$var wire 1 ( sw $end
$var wire 10 ) led [9:0] $end
$var wire 1 * btnC $end
$var wire 1 + btnU $end
$scope module onehot $end
$var wire 1 ( w $end
$var wire 1 * clk $end
$var wire 1 + rs $end
$var wire 1 , z $end
$var wire 5 - state [6:2] $end
$var wire 1 . Anext $end
$var wire 1 / Bnext $end
$var wire 1 0 Cnext $end
$var wire 1 1 Dnext $end
$var wire 1 2 Enext $end
$scope module Adff $end
$var wire 1 3 Default $end
$var wire 1 . D $end
$var wire 1 * clk $end
$var wire 1 + reset $end
$var reg 1 4 Q $end
$upscope $end
$scope module Bdff $end
$var wire 1 5 Default $end
$var wire 1 / D $end
$var wire 1 * clk $end
$var wire 1 + reset $end
$var reg 1 6 Q $end
$upscope $end
$scope module Cdff $end
$var wire 1 7 Default $end
$var wire 1 0 D $end
$var wire 1 * clk $end
$var wire 1 + reset $end
$var reg 1 8 Q $end
$upscope $end
$scope module Ddff $end
$var wire 1 9 Default $end
$var wire 1 1 D $end
$var wire 1 * clk $end
$var wire 1 + reset $end
$var reg 1 : Q $end
$upscope $end
$scope module Edff $end
$var wire 1 ; Default $end
$var wire 1 2 D $end
$var wire 1 * clk $end
$var wire 1 + reset $end
$var reg 1 < Q $end
$upscope $end
$upscope $end
$scope module bin $end
$var wire 1 ( w $end
$var wire 1 * clk $end
$var wire 1 + rs $end
$var wire 1 = z $end
$var wire 3 > state [9:7] $end
$var wire 3 ? Next [2:0] $end
$scope module zero $end
$var wire 1 @ Default $end
$var wire 1 A D $end
$var wire 1 * clk $end
$var wire 1 + reset $end
$var reg 1 B Q $end
$upscope $end
$scope module one $end
$var wire 1 C Default $end
$var wire 1 D D $end
$var wire 1 * clk $end
$var wire 1 + reset $end
$var reg 1 E Q $end
$upscope $end
$scope module two $end
$var wire 1 F Default $end
$var wire 1 G D $end
$var wire 1 * clk $end
$var wire 1 + reset $end
$var reg 1 H Q $end
$upscope $end
$upscope $end
$upscope $end
$scope task toggle_clock $end
$upscope $end
$scope task check_state_oh $end
$upscope $end
$scope task check_state_bn $end
$upscope $end
$scope task check_state $end
$upscope $end
$scope task do_reset $end
$upscope $end
$scope task next_state $end
$upscope $end
$upscope $end
$enddefinitions $end

#0
$dumpvars
0!
0"
x#
0$
0%
b1 &
b0 '
0(
b100 )
0*
x+
0,
b1 -
0.
1/
00
01
02
13
14
05
06
07
08
09
0:
0;
0<
0=
b0 >
b1 ?
0@
1A
0B
0C
0D
0E
0F
0G
0H
$end

#1000
1#
1+

#2000
0#
0+

#3000
1"
b10 &
b1 '
b10001000 )
1*
b10 -
0/
10
04
16
b1 >
b10 ?
0A
1B
1D

#4000
0"
0*

#5000
1"
1$
1%
b100 &
b10 '
b100010011 )
1*
1,
b100 -
06
18
1=
b10 >
0B
1E

#6000
0"
0*

#7000
1"
1*

#8000
1!
0"
1(
0*
00
11
b11 ?
1A

#9000
1"
0$
0%
b1000 &
b11 '
b110100000 )
1*
0,
b1000 -
01
12
08
1:
0=
b11 >
b100 ?
0A
1B
0D
1G

#10000
0"
0*

#11000
1"
1$
1%
b10000 &
b100 '
b1001000011 )
1*
1,
b10000 -
0:
1<
1=
b100 >
0B
0E
1H

#12000
0"
0*

#13000
1"
1*

#14000
0!
0"
0(
0*
1/
02
b1 ?
1A
0G

#15000
1"
0$
0%
b10 &
b1 '
b10001000 )
1*
0,
b10 -
0/
10
16
0<
0=
b1 >
b10 ?
0A
1B
1D
0H

#16000
1!
0"
1(
0*
00
11
b11 ?
1A

#17000
1"
b1000 &
b11 '
b110100000 )
1*
b1000 -
01
12
06
1:
b11 >
b100 ?
0A
0D
1E
1G

#18000
0!
0"
0(
0*
1/
02
b1 ?
1A
0G

#19000
1"
b10 &
b1 '
b10001000 )
1*
b10 -
0/
10
16
0:
b1 >
b10 ?
0A
1D
0E

#20000
0"
0*

#21000
1#
b1 &
b0 '
b100 )
1+
b1 -
1/
00
14
06
b0 >
b1 ?
1A
0B
0D

#22000
1!
0#
1(
0+
0/
11
b11 ?
1D

#23000
1"
b1000 &
b11 '
b110100000 )
1*
b1000 -
01
12
04
1:
b11 >
b100 ?
0A
1B
0D
1E
1G

#24000
0"
